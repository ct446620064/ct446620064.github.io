{"meta":{"title":"小泽のブログ","subtitle":"","description":"","author":"realxz","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2021-01-01T13:43:02.000Z","updated":"2021-01-01T13:43:02.036Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"search","date":"2021-01-01T13:42:55.000Z","updated":"2021-01-01T13:42:55.116Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"A Docker Guide for Java","slug":"A Docker Guide for Java","date":"2021-01-11T16:00:00.000Z","updated":"2021-01-13T08:47:11.319Z","comments":true,"path":"2021/01/12/A Docker Guide for Java/","link":"","permalink":"http://example.com/2021/01/12/A%20Docker%20Guide%20for%20Java/","excerpt":"","text":"参考资料：https://www.baeldung.com/docker-java-api 1.概述在这篇文章中，我们看一下另一个建立已久的平台的具体的API—-Java API Client for Docker 通过这篇文章，我们理解如何连接一个正在运行的Docker守护进程的方式，还有这个API为Java开发人员提供了什么样的重要智能。 2.Maven Dependency首先，我们需要添加一个主要的依赖到我们的pom.xml文件中： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt; &lt;artifactId&gt;docker-java&lt;/artifactId&gt; &lt;version&gt;3.0.14&lt;/version&gt;&lt;/dependency&gt; 写这文章的时候，这个API的最新版本是3.0.14。每个发行版可以从the github release page或者 the maven repository浏览。 3.使用Docker ClientDockerClient 是一个我们在Docker 引擎/守护进程和我们应用程序之间建立连接的地方。 默认情况下，Docker 守护进程只能在unix:///var/run/docker.sock file访问。在本地，我们可以通过监听the Unix socket与Doocker引擎交流，并且这样无需任何配置。 在这，我可使用DockerClientBuilder类去创建一个连接，这个连接使用的是默认的配置： DockerClient dockerClient = DockerClientBuilder.getInstance().build(); 简单的，我们可以使用以下两步打开一个连接： DefaultDockerClientConfig.Builder config = DefaultDockerClientConfig.createDefaultConfigBuilder(); DockerClient dockerClient = DockerClientBuilder .getInstance(config) .build(); 由于引擎可以依赖其他特征，客户端也可以在不同条件下配置。 例如，the builder 接受一个server URL，如果引擎在端口2375可用的话，我们能更新连接值。 DockerClient dockerClient = DockerClientBuilder.getInstance(\"tcp://docker.baeldung.com:2375\").build(); 注意，我们需要在连接字符串 (connection string)前加上unix:// 或者 tcp://，这依赖于连接类型 (connection type)。 进一步，我们能以一个更高级的配置，这个配置使用DefaultDockerClientConfig类。 DefaultDockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder() .withRegistryEmail(“&#105;&#x6e;&#x66;&#x6f;&#64;&#x62;&#97;&#101;&#108;&#100;&#117;&#x6e;&#x67;&#x2e;&#x63;&#111;&#109;“) .withRegistryPassword(“baeldung”) .withRegistryUsername(“baeldung”) .withDockerCertPath(“/home/baeldung/.docker/certs”) .withDockerConfig(“/home/baeldung/.docker/“) .withDockerTlsVerify(“1”) .withDockerHost(“tcp://docker.baeldung.com:2376”).build(); DockerClient dockerClient = DockerClientBuilder.getInstance(config).build(); 同样地，我们可以使用Properties执行相同的方法。 Properties properties = new Properties();properties.setProperty(“registry.email”, “&#x69;&#x6e;&#x66;&#111;&#x40;&#98;&#x61;&#101;&#108;&#x64;&#x75;&#110;&#x67;&#x2e;&#99;&#x6f;&#109;“);properties.setProperty(“registry.password”, “baeldung”);properties.setProperty(“registry.username”, “baaldung”);properties.setProperty(“DOCKER_CERT_PATH”, “/home/baeldung/.docker/certs”);properties.setProperty(“DOCKER_CONFIG”, “/home/baeldung/.docker/“);properties.setProperty(“DOCKER_TLS_VERIFY”, “1”);properties.setProperty(“DOCKER_HOST”, “tcp://docker.baeldung.com:2376”); DefaultDockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder() .withProperties(properties).build(); DockerClient dockerClient = DockerClientBuilder.getInstance(config).build(); 除非我们在源代码里面配置引擎设置，否则另一个选择是设置想符合的环境变量，以至于我们只考虑项目中DockerClient的默认的实例化。 export DOCKER_CERT_PATH=/home/baeldung/.docker/certsexport DOCKER_CONFIG=/home/baeldung/.docker/export DOCKER_TLS_VERIFY=1export DOCKER_HOST=tcp://docker.baeldung.com:2376 4.容器管理这个API给予我们关于容器管理的各种各样的选择。让我们看看每一个。 4.1容器列表 List Container现在，我们已经建立了连接，我们能列出位于Docker主机上的所有正在运行的容器。 List containers = dockerClient.listContainersCmd().exec(); 假如显示正在运行的容器不满足要求，我们能使用选项查询容器。 List containers = dockerClient.listContainersCmd().withShowSize(true) .withShowAll(true) .withStatusFilter(“exited”).exec() 它就等价于： $ docker ps -a -s -f status=exitedor $ docker container ls -a -s -f status=exited 4.2创建容器创建容器由createContainerCmd方法提供。我们可以使用以“with”为前缀的方法进行更复杂的声明。 假定我们有一个docker create 命令，定义了一个依赖于主机的MongoDB容器并在容器内部监听27017端口： 123456$ docker create --name mongo \\ --hostname=baeldung \\ -e MONGO_LATEST_VERSION=3.6 \\ -p 9999:27017 \\ -v /Users/baeldung/mongo/data/db:/data/db \\ mongo:3.6 --bind_ip_all 我们能以变成的方式启动同样的容器，并对其进行配置： 12345678CreateContainerResponse container = dockerClient.createContainerCmd(&quot;mongo:3.6&quot;) .withCmd(&quot;--bind_ip_all&quot;) .withName(&quot;mongo&quot;) .withHostName(&quot;baeldung&quot;) .withEnv(&quot;MONGO_LATEST_VERSION=3.6&quot;) .withPortBindings(PortBinding.parse(&quot;9999:27017&quot;)) .withBinds(Bind.parse(&quot;/Users/baeldung/mongo/data/db:/data/db&quot;)).exec(); 4.3 start、stop和kill container一旦我们创建了容器，我们就能通过容器名字name或者容器id，启动start、停止stop和杀死kill这个容器： 12345dockerClient.startContainerCmd(container.getId()).exec();dockerClient.stopContainerCmd(container.getId()).exec();dockerClient.killContainerCmd(container.getId()).exec(); 4.4 查看inspect 容器inspectContainerCmd 方法有一个String类型的参数，这个参数指明容器的name或者id。使用这个方法，我们能直接地观察容器的元数据metadate： 12InspectContainerResponse container &#x3D; dockerClient.inspectContainerCmd(container.getId()).exec(); 4.5 Snapshot 快照 容器 类似与docker commit 命令，我们能使用commitCmd方法创建一个新的镜像。 在我们的例子中，这个场景是，我们先前运行一个 alpine:3.6容器，它的id是“*3464bb547f88*”，并且在它的顶部安装了git。 现在，我们想从这个容器中创建一个新的镜像快照： 1234567String snapshotId &#x3D; dockerClient.commitCmd(&quot;3464bb547f88&quot;) .withAuthor(&quot;Baeldung &lt;info@baeldung.com&gt;&quot;) .withEnv(&quot;SNAPSHOT_YEAR&#x3D;2018&quot;) .withMessage(&quot;add git support&quot;) .withCmd(&quot;git&quot;, &quot;version&quot;) .withRepository(&quot;alpine&quot;) .withTag(&quot;3.6.git&quot;).exec(); 由于与git捆绑的新镜像仍保留在主机上，我们能在Docker主机上搜索到它： 123$ docker image ls alpine --format &quot;table &#123;&#123;.Repository&#125;&#125; &#123;&#123;.Tag&#125;&#125;&quot;REPOSITORY TAGalpine 3.6.git 5.镜像管理我们提供了一些适用的命令来管理镜像操作。 5.1列出镜像列出Docker主机上的所有镜像（包括悬挂镜像），我们需要应用的是listImagesCmd命令： 1List&lt;Image&gt; images &#x3D; dockerClient.listImagesCmd().exec(); 如果在Docker主机上我们有两个镜像，我们应该在运行时获得它们的*Image*对象。我们要寻找的镜像是： 1234$ docker image ls --format &quot;table &#123;&#123;.Repository&#125;&#125; &#123;&#123;.Tag&#125;&#125;&quot;REPOSITORY TAGalpine 3.6mongo 3.6 接下来，要看中间镜像，我们需要明确地请求它： 12List&lt;Image&gt; images &#x3D; dockerClient.listImagesCmd() .withShowAll(true).exec(); 如果在这个情况下，只显示悬挂镜像，必须考虑withDanglingFilter方法： 12List&lt;Image&gt; images &#x3D; dockerClient.listImagesCmd() .withDanglingFilter(true).exec(); 5.2构建镜像我们专注于使用API方式构建镜像。用buildImageCmd方法从Dockerfile中构建镜像。在我们的项目中，我们已经有了一个Dockerfile文件，这个Dockerfile定义了一个 安装了git的Alpine镜像： 12345678FROM alpine:3.6RUN apk --update add git openssh &amp;&amp; \\ rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* &amp;&amp; \\ rm &#x2F;var&#x2F;cache&#x2F;apk&#x2F;*ENTRYPOINT [&quot;git&quot;]CMD [&quot;--help&quot;] 在构建进程开始之前，新镜像无需使用缓存就能被创建，在任何情况下，docker 引擎将尝试拉取较新版本的alpine:3.6。如果一切顺利，最终我们应该看到具有给定名称的alpine:git镜像： 1234567String imageId &#x3D; dockerClient.buildImageCmd() .withDockerfile(new File(&quot;path&#x2F;to&#x2F;Dockerfile&quot;)) .withPull(true) .withNoCache(true) .withTag(&quot;alpine:git&quot;) .exec(new BuildImageResultCallback()) .awaitImageId(); 5.3查看镜像使用inspectImageCmd方法，我们可以查看镜像的底层信息： 1 12InspectImageResponse image = dockerClient.inspectImageCmd(&quot;161714540c41&quot;).exec(); 5.4给图像版本号使用docker tag 命令给我们的镜像添加版本号是非常简单的，这个API也不例外。我们可以使用tagImageCmd 命令来完成同样的目的。使用git将镜像id为*161714540c41*的镜像标记到baeldung/alpine库中，请执行以下操作： 12345String imageId &#x3D; &quot;161714540c41&quot;;String repository &#x3D; &quot;baeldung&#x2F;alpine&quot;;String tag &#x3D; &quot;git&quot;;dockerClient.tagImageCmd(imageId, repository, tag).exec(); 我们可以列出最新创建的镜像，如下所示： 1 123$ docker image ls --format &quot;table &#123;&#123;.Repository&#125;&#125; &#123;&#123;.Tag&#125;&#125;&quot;REPOSITORY TAGbaeldung/alpine git 5.5推送镜像在推送镜像到注册服务之前，docker client必须配置，以便与这个服务协作，因为与注册服务工作需要提前获取授权。 因为假定我们的客户端配置了Docker Hub，所以我们可以将baeldung/alpine镜像推送到baeldung DockerHub账户上。 1234dockerClient.pushImageCmd(&quot;baeldung&#x2F;alpine&quot;) .withTag(&quot;git&quot;) .exec(new PushImageResultCallback()) .awaitCompletion(90, TimeUnit.SECONDS); 我们必须容忍持续的进程。在这个例子中，我们等待了90秒。 5.6拉取镜像从注册服务中拉取镜像，我们利用pullImageCmd方法。另外，如果镜像是从私有库中拉取，客户端必须知道我们的证书，否则这个过程就会停止并报错。等同于拉取镜像，我们指定一个回调和一个固定的周期拉取镜像： 1234dockerClient.pullImageCmd(&quot;baeldung&#x2F;alpine&quot;) .withTag(&quot;git&quot;) .exec(new PullImageResultCallback()) .awaitCompletion(30, TimeUnit.SECONDS); 拉取完成后，检查Docker主机中是否存在我们提及的镜像： 123$ docker images baeldung&#x2F;alpine --format &quot;table &#123;&#123;.Repository&#125;&#125; &#123;&#123;.Tag&#125;&#125;&quot;REPOSITORY TAGbaeldung&#x2F;alpine git 5.7删除镜像剩下的函数中的另一个简单的函数是removeImageCmd方法。我们可以使用它的短或长ID删除镜像： 1dockerClient.removeImageCmd(&quot;beaccc8687ae&quot;).exec(); 5.8在注册中搜索从Docer Hub上搜索镜像，客户端附带一个searchImagesCmd方法，这个方法要指定一个字符串类型的值，这个值指示了要搜索的词。在这，我们探索Docker Hub中包含‘java’的镜像。 1List&lt;SearchItem&gt; items &#x3D; dockerClient.searchImagesCmd(&quot;Java&quot;).exec(); 输出返回的SearchItem对象中列出了前25过热相关的镜像。 6.卷管理如果java项目需要使用卷与Docker进行交互，我们也应该重视这一章节。简短地，我们查看由Docker Java API提供的卷的基本技术。 6.1列出卷包括有名的和无名的所有可用的卷都被列出： 1234ListVolumesResponse volumesResponse &#x3D; dockerClient.listVolumesCmd().exec();List&lt;InspectVolumeResponse&gt; volumes &#x3D; volumesResponse.getVolumes(); 6.2查看卷inspectVolumeCmd方法是显示一个卷详细信息的窗体。我们通过指定卷id查看卷： 12InspectVolumeResponse volume &#x3D; dockerClient.inspectVolumeCmd(&quot;0220b87330af5&quot;).exec(); 6.3创建卷这个API提供了两个不同的选项进行创建卷。无参数的createVolumeCmd方法创建一个卷，这个卷的名字由Docker生成： 1CreateVolumeResponse unnamedVolume &#x3D; dockerClient.createVolumeCmd().exec(); 要不使用默认的行为，这个withName的方法允许我们给卷命名： 12CreateVolumeResponse namedVolume = dockerClient.createVolumeCmd().withName(&quot;myNamedVolume&quot;).exec(); 6.4删除卷我们可以使用removeVolumeCmd方法从Docker主机中直观地删除一个卷。要注意的是，如果一个卷正在被容器使用，我们不能删除这个卷，这点很重要。我们从卷列表中删除卷，myNamedVolume： 1dockerClient.removeVolumeCmd(&quot;myNamedVolume&quot;).exec(); 7.网络管理我们最后一节是关于用API管理网络任务。 7.1列出网络我们可以使用一种传统的API方法，列出网络单元的列表，从列表开始： 1List&lt;Network&gt; networks &#x3D; dockerClient.listNetworksCmd().exec(); 7.2创建网络执行createNetworkCmd命令就等价于docker network create c命令。如果我们有三部分或者一个客户网络驱动，withDriver方法能接受这些除了嵌入驱动。在我们的例子中，让我们创建一个桥接网络，它的名字是baeldung： 1234CreateNetworkResponse networkResponse = dockerClient.createNetworkCmd() .withName(&quot;baeldung&quot;) .withDriver(&quot;bridge&quot;).exec(); 更进一步，使用默认设置创建一个网络单元不能解决问题，我们可以应用其他辅助方法来构建高级网络。因此，用自定义值覆盖默认子网络： 123456789CreateNetworkResponse networkResponse &#x3D; dockerClient.createNetworkCmd() .withName(&quot;baeldung&quot;) .withIpam(new Ipam() .withConfig(new Config() .withSubnet(&quot;172.36.0.0&#x2F;16&quot;) .withIpRange(&quot;172.36.5.0&#x2F;24&quot;))) .withDriver(&quot;bridge&quot;).exec(); 我们可以使用docker命令运行的相同命令是： 1234$ docker network create \\ --subnet&#x3D;172.36.0.0&#x2F;16 \\ --ip-range&#x3D;172.36.5.0&#x2F;24 \\ baeldung 7.3查看网络展示网络的底层详细信息也包含在API中： 12Network network &#x3D; dockerClient.inspectNetworkCmd().withNetworkId(&quot;baeldung&quot;).exec(); 7.4删除网络我们能使用removeNetworkCmd方法根据网络名称和id安全地删除网络单元： 1dockerClient.removeNetworkCmd(&quot;baeldung&quot;).exec(); 8总结在这个广泛的教程中，我们探索Java Docker API Client中各种各样的功能，以及用于部署和管理场景的部署方法。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"将镜像发布到DockerHub","slug":"将Docker镜像发布到DockerHub","date":"2021-01-09T16:00:00.000Z","updated":"2021-01-11T09:11:59.345Z","comments":true,"path":"2021/01/10/将Docker镜像发布到DockerHub/","link":"","permalink":"http://example.com/2021/01/10/%E5%B0%86Docker%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0DockerHub/","excerpt":"","text":"步骤1：在DockerHub上注册帐号。 步骤2：本地登录DockerHub帐号 docker login 步骤3：使用docker tag命令将镜像重新命令并设置版本号 docker tag命令使用方式： docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] 如果要发布镜像到DockerHub，则TARGET_IMAGE的格式为 namespace/imagename。 namespace就是DockerHub的用户名 步骤4：使用命令提交镜像 docker push TARGET_IMAGE[:TAG]","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"使用Dockerfile构建镜像","slug":"使用Dockerfile构建镜像","date":"2021-01-08T16:00:00.000Z","updated":"2021-01-10T14:10:09.305Z","comments":true,"path":"2021/01/09/使用Dockerfile构建镜像/","link":"","permalink":"http://example.com/2021/01/09/%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/","excerpt":"","text":"使用Dockerfile构建镜像常用的Dockerfile指令： FORM # 基础环境镜像，一切从这里构建 MAINTAINER # 镜像是谁写的，姓名+邮箱 RUN # 镜像构建时需要运行的命令 ADD # COPY文件，会自动解压 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 暴露端口配置 CMD # 指定这个端口启动时要运行的命令，只有最后一个会生效，可被替代 ENTRYPOINT # 指定这个端口启动时要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承Dockerfile，这个时候就会运行 ONBUILD指令，触发指令 COPY # 类似ADD，将我们的文件拷贝到镜像中 ENV # 构建时候设置环境变量 测试1：构建一个属于自己的centos官方提供的centos镜像功能比较少，有些命令没有，比如：vim、ifconfig命令。 下面新建一个自定义Dockerfile文件，根据该文件构建一个包含vim、ifconfig命令的centos镜像。 步骤1：编写Dockerfile文件（文件名为mydockerfile-centos）： 1234567891011121314FROM centosMAINTAINER lize&lt;1729498179@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;-----end------&quot;CMD /bin/bash 步骤2：使用docker build命令构建自定义镜像 1$ docker build -f mydockerfile-centos -t mycentos:0.1 . 步骤3：使用自定义镜像新建一个容器并运行 1234567891011121314151617181920$ docker run -it mycentos:0.1[root@c4898d11d6f0 local]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.5 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:05 txqueuelen 0 (Ethernet) RX packets 23 bytes 3506 (3.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0[root@c4898d11d6f0 local]# vim test.txt 可以看到在这个容器中可以使用vim和ifconfig命令了。 拓展：查看镜像构建信息使用方法： docker history [镜像ID] 示例 1234567891011121314$ docker history 6366488f8808IMAGE CREATED CREATED BY SIZE COMMENT6366488f8808 15 minutes ago &#x2F;bin&#x2F;sh -c #(nop) CMD [&quot;&#x2F;bin&#x2F;sh&quot; &quot;-c&quot; &quot;&#x2F;bin… 0B af1077aebb21 15 minutes ago &#x2F;bin&#x2F;sh -c #(nop) CMD [&quot;&#x2F;bin&#x2F;sh&quot; &quot;-c&quot; &quot;echo… 0B bfbd94640b13 15 minutes ago &#x2F;bin&#x2F;sh -c #(nop) CMD [&quot;&#x2F;bin&#x2F;sh&quot; &quot;-c&quot; &quot;echo… 0B 40c2064da313 15 minutes ago &#x2F;bin&#x2F;sh -c #(nop) EXPOSE 80 0B 902c67b4a156 15 minutes ago &#x2F;bin&#x2F;sh -c yum -y install net-tools 23.4MB db8d734a53a3 15 minutes ago &#x2F;bin&#x2F;sh -c yum -y install vim 58.1MB 2f1b2c15ebcf 23 minutes ago &#x2F;bin&#x2F;sh -c #(nop) WORKDIR &#x2F;usr&#x2F;local 0B 71fd07af8e5c 23 minutes ago &#x2F;bin&#x2F;sh -c #(nop) ENV MYPATH&#x3D;&#x2F;usr&#x2F;local 0B 1e96df00e9c4 23 minutes ago &#x2F;bin&#x2F;sh -c #(nop) MAINTAINER lize&lt;172949817… 0B 300e315adb2f 4 weeks ago &#x2F;bin&#x2F;sh -c #(nop) CMD [&quot;&#x2F;bin&#x2F;bash&quot;] 0B &lt;missing&gt; 4 weeks ago &#x2F;bin&#x2F;sh -c #(nop) LABEL org.label-schema.sc… 0B &lt;missing&gt; 4 weeks ago &#x2F;bin&#x2F;sh -c #(nop) ADD file:bd7a2aed6ede423b7… 209MB 测试2：Dockerfile中的CMD命令步骤1：Dockerfile: docker-cmd-test 12FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;] 启动容器后并执行ls -a命令。 步骤2：构建镜像 1$ docker build -f dockerfile-cmd-test -t cmdtest . 步骤3：运行容器 1234567891011121314151617181920212223$ docker run ba526c95ec4e....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar 可以看到运行容器时，执行了Dockerfile中的CMD命令是ls -a。 如果在运行容器时，后面追加一个选项参数，比如-l，那么这个命令将会替换掉Dockerfile中的CMD命令，所以实际执行的命令为ls -l 但是又因为-al是一个命令，而-l不是一个完整的命令，所以这样做会报错，如下： 1234$ docker run ba526c95ec4e -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.ERRO[0000] error waiting for container: context canceled 测试3：Dockerfile中的ENTRYPOINT命令步骤1：ENTRYPOINT命令和CMD命令基本一样，构建Dockerfile如下： 12FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] 启动容器后并执行ls -a命令。 步骤2：构建镜像： 1$ docker build -f dockerfile-entrypoint-test -t entrypoint-test . 步骤3：运行容器： 1234567891011121314151617181920212223$ docker run 40f8e8c455cf....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar 运行容器后和ENTRYPOINT命令一样同样执行了ls -a命令。 如果运行容器时追加了-l命令，则-l命令会追加到ENTRYPOINT命令后面，实际执行的是ls -al命令，如下： 12345678910111213141516171819202122232425$ docker run 40f8e8c455cf -ltotal 56drwxr-xr-x 1 root root 4096 Jan 9 13:43 .drwxr-xr-x 1 root root 4096 Jan 9 13:43 ..-rwxr-xr-x 1 root root 0 Jan 9 13:43 .dockerenvlrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Jan 9 13:43 devdrwxr-xr-x 1 root root 4096 Jan 9 13:43 etcdrwxr-xr-x 2 root root 4096 Nov 3 15:22 homelrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Dec 4 17:37 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 15:22 mediadrwxr-xr-x 2 root root 4096 Nov 3 15:22 mntdrwxr-xr-x 2 root root 4096 Nov 3 15:22 optdr-xr-xr-x 292 root root 0 Jan 9 13:43 procdr-xr-x--- 2 root root 4096 Dec 4 17:37 rootdrwxr-xr-x 11 root root 4096 Dec 4 17:37 runlrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 15:22 srvdr-xr-xr-x 13 root root 0 Jan 9 13:43 sysdrwxrwxrwt 7 root root 4096 Dec 4 17:37 tmpdrwxr-xr-x 12 root root 4096 Dec 4 17:37 usrdrwxr-xr-x 20 root root 4096 Dec 4 17:37 var 小结CMD命令和ENTRYPOINT命令的区别： 相同之处：都是启动容器后执行命令。 不同之处：如果运行容器时追加命令，那这条追加命令会替换掉CMD命令，而这条追加命令会追加到ENTRYPOINT命令的后面。 实战1：构建自定义tomcat镜像步骤1：构建Dockerfile文件如下： 123456789101112131415161718192021222324FROM centosMAINTAINER lize&lt;1729498179@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u201-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.41.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_201ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.41ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh $$ tail -F /usr/local/apache-tomcat-9.0.41/bin/logs/catalina.out 步骤2：创建镜像 1$ docker build -t mytomcat . Dockerfile文件以命名为Dockerfile，那么在该目录创建镜像时无需使用-f指定Dockerfile文件所在位置。 步骤3：运行容器 1$ docker run -d -p 9090:8080 --name mytomcat-test -v /home/&#123;username&#125;/test/docker-test/docker-tomcat-test/volume/logs:/usr/local/apache-tomcat-9.0.41/logs -v /home/&#123;username&#125;/test/docker-test/docker-tomcat-test/volume/webapps:/usr/local/apache-tomcat-9.0.41/webapps mytomcat 步骤4：添加项目 $ cat ./volume/webapps/test/WEB-INF/web.xml 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;&lt;/web-app&gt; $ cat ./volume/webapps/test/index.jsp 12345678910111213141516171819&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;docker tomcat test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Hello world&lt;/h2&gt;&lt;/tr&gt;&lt;% System.out.println(&quot;----successful---&quot;);%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 步骤5：测试访问 在主机输入localhost:9090/test出现Hello World成功，查看catalina.out文件，出现打印记录即成功。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"Docker容器之间同步数据","slug":"Docker容器之间同步数据","date":"2021-01-08T16:00:00.000Z","updated":"2021-01-09T04:05:03.351Z","comments":true,"path":"2021/01/09/Docker容器之间同步数据/","link":"","permalink":"http://example.com/2021/01/09/Docker%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/","excerpt":"","text":"首先启动一个名为docker01的容器。 然后运行下面这个命令，新建一个名为docker02的容器。 1$ docker run -it --name docker02 --volumes-from docker01 lize/centos:1.0 –volumes-from 就表示将docker01容器的数据卷同步到新建的这个容器中。 若在docker01容器内对数据卷中的内容进行修改，那么这些修改就会同步到docker02容器的数据卷内。 反过来，若在docker02容器内对数据卷中的内容进行修改，那么这些修改也会同步到docker01容器的数据卷内。 即使将docker01容器彻底删除，docker02容器内的数据卷也会依旧存在。 这个数据卷的同步机制是通过双向拷贝数据实现的，所以即使删除“父容器”后，“子容器”内的数据卷不会受影响。 等到同步数据卷的容器全部停止后，这个同步的数据卷则被删除（本地持久化后的数据不会被删除）。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"Docker匿名挂载和具名挂载","slug":"Docker匿名挂载和具名挂载","date":"2021-01-07T16:00:00.000Z","updated":"2021-01-08T14:20:32.025Z","comments":true,"path":"2021/01/08/Docker匿名挂载和具名挂载/","link":"","permalink":"http://example.com/2021/01/08/Docker%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD%E5%92%8C%E5%85%B7%E5%90%8D%E6%8C%82%E8%BD%BD/","excerpt":"","text":"总结： -v 容器内路径 #匿名挂载 -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 使用数据卷挂载时通常要指定主机目录和容器内目录。 而匿名挂载是不指定主机目录，让Docker在主机生成一个目录用来完成主机目录和容器目录之间的挂载。 匿名挂载示例：-v 后面只用写容器内的目录 1$ docker run -d -P --name nginx01 -v /etc/nginx nginx 查看已挂载的卷：123456$ docker volume lsDRIVER VOLUME NAMElocal b3b5c49a7b70d051d7e6016315802e0e76e2fcf51c6f063154e6003ea4bacc64local c2e4e840333c3822a97c72237aa193a5c86117814d3d650b784a4ebde775dafclocal cout-test-vol 具名挂载示例：-v后面的格式是主机卷名称:容器内目录 1$ docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx 再次查看已挂载的卷：123456$ docker volume ls DRIVER VOLUME NAMElocal b3b5c49a7b70d051d7e6016315802e0e76e2fcf51c6f063154e6003ea4bacc64local c2e4e840333c3822a97c72237aa193a5c86117814d3d650b784a4ebde775dafclocal cout-test-vollocal test-nginx 多出一个名为test-nginx 的卷。 查看这个卷的详细信息： 123456789101112$ docker volume inspect test-nginx[ &#123; &quot;CreatedAt&quot;: &quot;2021-01-08T22:01:26+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/test-nginx/_data&quot;, &quot;Name&quot;: &quot;test-nginx&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 可见，Docker将主机上生成了/var/lib/docker/volumes/test-nginx/_data目录，并将该目录与容器内指定目录进行了双向绑定。 拓展：123456789# 通过 -v 容器内路径: ro rw 改变读写权限ro read only # 只读rw read write # 可读可写# 一旦设置了容器权限，容器对我们挂在出来的内容就有限定了$ docker run -d -P --name nginx02 -v test-nginx:/etc/nginx:ro nginx$ docker run -d -P --name nginx02 -v test-nginx:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，而容器内部无法操作","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"使用dockerfile创建Docker镜像","slug":"使用dockerfile创建Docker镜像","date":"2021-01-07T16:00:00.000Z","updated":"2021-01-09T02:29:15.697Z","comments":true,"path":"2021/01/08/使用dockerfile创建Docker镜像/","link":"","permalink":"http://example.com/2021/01/08/%E4%BD%BF%E7%94%A8dockerfile%E5%88%9B%E5%BB%BADocker%E9%95%9C%E5%83%8F/","excerpt":"","text":"初识DockerfileDockerfile是用来构建docker镜像的文件，类似一个命令脚本。 通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个命令，每个命令就是一层。 首先创建Dockerfile文件： 1234FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;------end------&quot;CMD &#x2F;bin&#x2F;bash 运行docker build命令和Dockerfile构建镜像： 1$ docker build -f dockerfile1 -t lize/centos:1.0 . -f 要指定Dockerfile的位置 -t 设置镜像名称:版本号 最后一个.表示在当前目录 根据自己创建的镜像新建容器并运行： 1$ docker run -it 36ac6c176d0a /bin/bash 查看容器内目录： 123456789101112131415161718192021222324[root@e75adb7db14d /]# ls -ltotal 56lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -&gt; usr/bindrwxr-xr-x 5 root root 360 Jan 8 14:58 devdrwxr-xr-x 1 root root 4096 Jan 8 14:58 etcdrwxr-xr-x 2 root root 4096 Nov 3 15:22 homelrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Dec 4 17:37 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 15:22 mediadrwxr-xr-x 2 root root 4096 Nov 3 15:22 mntdrwxr-xr-x 2 root root 4096 Nov 3 15:22 optdr-xr-xr-x 269 root root 0 Jan 8 14:58 procdr-xr-x--- 2 root root 4096 Dec 4 17:37 rootdrwxr-xr-x 11 root root 4096 Dec 4 17:37 runlrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 15:22 srvdr-xr-xr-x 13 root root 0 Jan 8 14:58 sysdrwxrwxrwt 7 root root 4096 Dec 4 17:37 tmpdrwxr-xr-x 12 root root 4096 Dec 4 17:37 usrdrwxr-xr-x 20 root root 4096 Dec 4 17:37 vardrwxr-xr-x 2 root root 4096 Jan 8 14:58 volume01drwxr-xr-x 2 root root 4096 Jan 8 14:58 volume02 发现Dockerfile中设置的挂载卷目录volume01和volume02。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"PPA","slug":"PPA","date":"2021-01-06T16:00:00.000Z","updated":"2021-01-08T07:26:48.808Z","comments":true,"path":"2021/01/07/PPA/","link":"","permalink":"http://example.com/2021/01/07/PPA/","excerpt":"","text":"PPA(Persional Package Archive)参考资料：https://itsfoss.com/ppa-guide/ 私人包存档，这暗示对一个开发人员独有的东西，是非官方支持的发布。 Ubuntu提供了一个叫做Launchpad的平台使软件开发人员能够创建属于他们自己的仓库。你可以将PPA repository加入到你的sources.list里面当你更新你的系统时，你的系统将知道新软件的可用性，并且你可以使用标准的sudo apt install命令安装这个软件。 123456# 将the PPA repository添加到list中sudo add-apt-repository ppa:dr-akulavich/lighttable# 更新the list of the packages that can be installed on the systemsudo apt-get update# 安装the packagesudo apt-get install lighttable-installer sudo add-apt-repository ppa:dr-akulavich/lighttable 这个命令中没有URL，是因为the tool被设计使用抽象信息表达URL。 如果你添加ppa:dr-akulavich/lighttable，那么你就会获得Light Table，但是如果你添加ppa:dr-akulavich，那么你就会获得一个更高级库里面所有的库和软件包，它是分层的。 基本上，当你使用add-apt-repository命令添加PPA时所做的操作就如同运行下面这些命令： deb http://ppa.launchpad.net/dr-akulavich/lighttable/ubuntu YOUR_UBUNTU_VERSION_HERE maindeb-src http://ppa.launchpad.net/dr-akulavich/lighttable/ubuntu YOUR_UBUNTU_VERSION_HERE main 上面这两行是添加任何仓库（repositories）到你的sources.list的传统方式。 但是PPA对你来说是自动的，无需担心精准的repository URL地址和操作系统版本。 一个要提及的重要的事就是当你使用PPA的时候，他不会改变你的原来的sources.list文件，而它会在/etc/apt/sources.d目录中创建两个文件，一个list文件和一个备份文件（后缀为save）。 以list为后缀的文件包含添加关于库的信息的命令。 这是一个确保添加PPA不会弄乱原来的sources.list文件的安全的措施，也可以帮助删除PPA。 为什么是PPA？为什么不是DEB包？你也许会问为什么你应该使用PPA，当涉及到使用不是每个人偏爱的命令行的时候。为什么不直接发布能详细安装的DEB包？ 答案在于更新过程。如果你使用DEB包安装软件，则不能保证安装的软件在你运行sudo apt update &amp;&amp; sudo apt upgrade命令时能被更新。 因为apt upgrade过程依赖sources.list，如果没有软件条目，那么他就无法通过标准软件更新获得更新。 所以，这就意味着使用DEB包安装的软件将永远不会获得更新？不是，这要看这个包是如何被创建的。 一些开发者自动添加一个条目到sources.list，然后这个软件就像常规软件那样更新。Google Chrome就是这样一个例子。 当你试图运行一些软件时，它会通知你新版本的可用性。你将不得不下载一个新的DEB包，然后再次运行以更新当前软件到一个新的版本。Oracle Virtual Box就是这样一个例子。 对于剩下的DEB包，你将不得不手动寻找一个更新，并且这样并不方便，特别是如果你的软件是为了beta测试者。你需要频繁地添加更多的更新。这就是PPA抢救的地方。 官方的PPA vs 非官方的PPA你可能听说过官方的PPA和非官方的PPA。两者有什么不同？ 当开发者为他们的软件创建一个PPA时，这个PPA就被称作官方的PPA。很明显，它来自于项目开发人员。 但是有时候，个人创建一个项目的PPA，但这个项目由其他人创建。 为什么有些人这样做？因为有些开发人员仅仅提供软件的源代码，并且你知道installing software from source code in Linux 是痛苦的，不是所有人可以或者愿意这样做。 这就是为什么志愿者自己根据这些源代码创建PPA，以便其他使用者能容易地安装软件，毕竟，使用那3行命令要比源代码安装容易的多。 确保PPA对你的发行版本是可用的当在Ubuntu或其他基于Debian的发行版来说，有一点事情要牢记。 不是所有的PPA对你的特定的发行版是可用的。你应该知道哪一个Ubuntu版本是你正在使用的。发行的codename是重要的，因为当你转到某个PPA网页时，你能看到那一个Ubuntu版本是PPA所支持的。 对于其他基于Ubuntu的发行版，你可以检查这目录/etc/os-release，找到Ubuntu 的版本信息。 https://itsfoss.com/how-to-know-ubuntu-unity-version/ 如何知道PPA的URL呢？在网络上简单搜索PPA的名称，如ppa:dr-akulavich/lighttable 并且你应该获得Launchpad网站的第一个结果，Launchpad是存储PPA的官方平台。在那你也能直接地去发布和搜索需要的PPA。 如果你没有核实并添加PPA，当你尝试去安装一个对你系统版本不可用的软件时，你可能看到一个错误： E: Unable to locate package 更糟糕的是自从它被加入到你的source.list后，你每次运行软件更新（software updater），你将会看到一个错误：Failed to download repository information 如果你在终端中运行sudo apt update命令，这可错误将会更详细地显示是哪一个库造成了这个问题。你能在输入命令后看到如下信息： W: Failed to fetch http://ppa.launchpad.net/venerix/pkg/ubuntu/dists/raring/main/binary-i386/Packages 404 Not FoundE: Some index files failed to download. They have been ignored, or old ones used instead. 无需解释，明显是因为系统无法发现使用于你的版本的库。 还记得我们之前看到的库结构吗？APT将尝试在http://ppa.launchpad.net/&lt;PPA_NAME&gt;/ubuntu/dists/Ubuntu_Version这个位置寻找软件信息。 并且如果PPA对于指定版本是不可用的，他将永远不能打开这个URL，并且你会看到著名的404错误。 为什么PPAs不是对所有的Ubuntu发行版都可用呢？这是因为有人必须编译这个软件并且在特定版本上创建PPA。考虑到每6个月发行一次Ubuntu版本，为每一个Ubuntu发行版更新PPA是一个烦人的任务。 如果PPA对你的版本是不可用，那么该如何安装应用程序？尽管PPA对你的版本是不可用的，那么安装程序也是可能的。你仍然可以下载DEB文件，然后安装这个应用程序。 假设你转到Light Table PPA页面。使用刚刚所学的PPA的知识，你了解到PPA是对你的Ubuntu版本不可用。 你能做的是点击View package details’ 在那，你能点击一个包去揭露更多详情信息。你也将发现源代码和DEB文件。 我建议使用using Gdebi to install these DEB files而不是软件中心，因为Gdebi是比处理依赖要好的多。 请注意，这种方式安装的软件包可能不会在未来更新。 我认为你已经阅读了关于添加PPAs足够多的内容。如何一处PPA并且由它安装的软件呢？ 如何删除PPA？我曾经写了关于如何删除PPA，我在这也会描述一些方法。 https://itsfoss.com/how-to-remove-or-delete-ppas-quick-tip/ 我建议你删除从PPA中安装的软件之前先删除PPA。如果你仅仅移除PPA，已安装的软件仍然在你的系统中，他不会获取任何更新。你不想这样，对吗？ 因此问题来了，如何知道那个应用使用哪个PPA安装的呢？ 寻找由PPA安装的package并删除他们Ubuntu的软件中心不会帮助。你将必须使用Synaptic package manager，它有更多高级特性。 你能在Ubuntu上安装Synaptic，或者使用以下命令： sudo apt install synaptic 安装后启动Synaptic package manager，并选择Origin。你将看到各种各样的加入到系统中的库。PPA条目以PPA为前缀。点击他们查看PPA可用的软件包。已安装的软件在它之前将会有适当的符号。 在你发现软件包之后，你能从Synaptic上删除他们。另外，你总是能使用这个命令： sudo apt remove package_name 在你删除由PPA安装的软件包后，你能从你的sources.list中继续删除这个PPA。 图形化地删除PPA打开Software &amp; Updates，然后打开Other Software标签。寻找你要删除的PPA。 在这你有两个选项。要不取消选定PPA，要不你选择Remove选项。 两者不同的是当你取消选定PPA条目时，你的系统将在/etc/apt/sources.list.d 目录下ppa_name.list 文件中注释掉库条目，但是你选择Remove选项它就会从/etc/apt/sources.list.d目录下ppa_name.list文件中删除库条目。 这两种情况，ppa_name.list文件存在于那个目录中，即使它是空的。 使用PPA安全吗？这是一个主观性的问题。纯粹主义者讨厌PPA，因为大多数情况下PPAs是来自与第三方开发者。但是与此同时，由于提供了一个更容易的安装选项，PPAs是在Debian/Ubuntu世界是受欢迎的。 就安全性而言，你使用PPA和Linux系统受到恶意软件的攻击或劫持是几乎不可能的。到目前为止，我想不起这种偶然事件曾经发生过。 官方PPAs能被使用，这无需多想。使用非官方PPA完全取决于你的决定。 根据经验，如果该程序需要sudo权限才能运行，则应避免通过第三方PPA安装该程序。","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://example.com/tags/ubuntu/"}]},{"title":"Docker常用命令","slug":"Docker","date":"2021-01-03T08:13:14.000Z","updated":"2021-01-08T13:25:01.963Z","comments":true,"path":"2021/01/03/Docker/","link":"","permalink":"http://example.com/2021/01/03/Docker/","excerpt":"","text":"Docker和虚拟机的不同： 传统虚拟机，虚拟出一套硬件，在硬件之上运行一个完整的操作系统，然后在操作系统上安装和运行软件。 容器内的应用直接运行在宿主机的内核上，容器没有自己的内核，也没有虚拟出硬件。 每个容器之间是相互隔离的，每个容器都有一个属于自己的文件系统，互不影响。 Docker镜像命令查看镜像使用方式： docker images [option] [repository[:TAG]] 示例： 12345678910111213$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 12 months ago 13.3kB# 解释#只显示镜像ID$ docker images -q7c3ce33e4a1fec3789272a09698ab9017c5b19d9cb152dda ​​ 字段名 含义 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像ID CREATED 镜像创建时间 SIZE 镜像的大小 Option选项 描述 –all , -a # 显示所有镜像 (default hides intermediate images) –digests # Show digests –filter , -f # Filter output based on conditions provided –format # Pretty-print images using a Go template –no-trunc #Don’t truncate output –quiet , -q # Only show image IDs 搜索镜像使用方式： docker search [OPTION] TERM 示例： 1234567$ docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10339 [OK] mariadb MariaDB is a community-developed fork of MyS… 3832 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 757 [OK].... 12345# 搜索时添加过滤条件为STARS不小于3000$ docker search mysql --filter=STARS=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10339 [OK] mariadb MariaDB is a community-developed fork of MyS… 3832 [OK] 查看某个命令的可选项使用方式： docker [命令名称] –help 示例： 12345678910111213$ docker images --helpUsage: docker images [OPTIONS] [REPOSITORY[:TAG]]List imagesOptions: -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Don&#x27;t truncate output -q, --quiet Only show numeric IDs 下载镜像使用方式： docker pull [OPTION] NAME[:TAG|@DIGEST] 示例： 123456789101112131415161718$ docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysql6ec7b7d162b2: Pull complete # 分层下载fedd960d3481: Pull complete 7ab947313861: Pull complete 64f92f19e638: Pull complete 3e80b17bff96: Pull complete 014e976799f9: Pull complete 59ae84fee1b3: Pull complete ffe10de703ea: Pull complete 657af6d90c83: Pull complete 98bfb480322c: Pull complete 6aa3859c4789: Pull complete 1ed875d851ef: Pull complete Digest: sha256:78800e6d3f1b230e35275145e657b82c3fb02a27b2d8e76aac2f5e90c1c30873 # 签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址 如果不写TAG，则默认下载最新的镜像。 以下两个命令等价： 12$ docker pull mysql$ docker pull docker.io/library/mysql:latest 指定版本下载： 12345678910111213$ docker pull mysql:5.75.7: Pulling from library/mysql6ec7b7d162b2: Already exists fedd960d3481: Already exists 7ab947313861: Already exists 64f92f19e638: Already exists 3e80b17bff96: Already exists 014e976799f9: Already exists 59ae84fee1b3: Already exists 7d1da2a18e2e: Pull complete 301a28b700b9: Downloading [============&gt; ] 26.25MB/108.3MB529dc8dbeaf3: Download complete bc9d021dc13f: Download complete 删除镜像使用方式： docker rmi [OPTIONS] IMAGE [IMAGE…] 示例： 123456$ docker rmi -f 882aebcdb308Deleted: sha256:882aebcdb308cd2f1dc333c3fc1676614ea0bd9b4379d0bfdf5db55640e56e56Deleted: sha256:7da399cc68d63c6d3540bad15369c46e971443bc73981df585a7a37aefd3983aDeleted: sha256:b480ebcefedc620f17a24d5c61a336361c075db1aaf57e2a1de32b97f69eb3a4Deleted: sha256:957eb1ae5cf15a8089a9b19aaacbacdaf06fb5045d6fb2bb95c3c37961b09081 删除所有的镜像： 1$ docker rmi -f $(docker images -aq) 其中$(docker images -aq)为查询所有镜像的ID Docker容器命令安装centos进行测试 1$ docker pull centos 新建容器并运行 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 示例： 1234$ docker run -it centos /bin/bash # 运行并进入容器[root@fbddb27d188f /]# ls # 查看容器内的centosbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@fbddb27d188f /]# exit # 从容器退回主机 查看容器 docker ps [OPTIONS] 示例： 12345$ docker ps # 查看当前正在运行的容器CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES$ docker ps -all # 列出当前运行的容器+查看曾经运行的容器CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfbddb27d188f centos &quot;/bin/bash&quot; 14 minutes ago Exited (0) 3 minutes ago happy_kowalevski Option名称 描述 -all, -a 显示所有容器 –last, -n 显示最近创建的n个容器 –quiet, -q 只显示容器的ID 退出容器退出并关闭容器 exit 退出但不关闭容器 Ctrl + P + Q 删除容器使用方式： docker rm [OPTIONS] CONTAINER [CONTAINER…] Option选项 描述 --force , -f Force the removal of a running container (uses SIGKILL) --link , -l Remove the specified link --volumes , -v Remove anonymous volumes associated with the container 示例： 12$ docker rm fbddb27d188ffbddb27d188f 启动容器 1$ docker start [容器ID] 重启容器 1$ docker restart [容器ID] 停止容器 1$ docker stop [容器ID] 强制停止当前容器 1$ docker kill [容器ID] 常用其他命令后台运行容器 1234567891011$ docker run -d centosf3cc16b38e9dc3e281681f226128b3f084aec79b9d9c27721a83f36189fdaebc# lize @ lize-linux in ~ [21:15:59] $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES# lize @ lize-linux in ~ [21:16:04] $ docker ps -all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf3cc16b38e9d centos &quot;/bin/bash&quot; 12 seconds ago Exited (0) 11 seconds ago elegant_archimedes docker run -d centos中的-d表示后台运行，但是该后台运行必须对应一个前台进程，否则docker会将这个容器停止。 查看日志 1$ docker logs -tf --tail 10 [容器ID] -tf表示显示日志， --tail [数字]表示要显示日志条数。 查看容器内部进程 1$ docker top [容器ID] 示例： 123$ docker top 8326642ceb7d UID PID PPID C STIME TTY TIME CMDroot 20286 20264 0 21:46 pts/0 00:00:00 /bin/bash 查看容器的元数据 1$ docker inspect [容器ID] 进入当前正在运行的容器 1$ docker exec -it [容器ID] bashshell 或者 1$ docker attach [容器ID] 两者区别：docker exec 在进入容器后开启一个新的终端，docker attach 在进入容器后使用正在执行的一个终端。 将容器内部的文件拷贝到主机上 1$ docker cp [容器ID]:[容器中的文件路径] [主机文件夹路径] ![](/home/lize/Pictures/Screenshot from 2021-01-05 23-14-52.png) 作业1：docker部署nginxdocker部署nginx并完成端口映射 12$ docker run -d --name nginx01 -p 3344:80 nginxf358c945ae0eed75160c006a0a3fac73028c9aa73f1ed2b87e6c12d708aa17fe 作业2：docker部署tomcat官方使用： 1$ docker run -it --rm tomcat --rm表示停止容器后将无法查询到该容器，先在本地镜像中寻找tomcat，本地镜像没有则去docker 仓库下载。 后台运行tomcat： 1$ docker run -d -p 3355:8080 --name tomcat01 tomcat 但是访问localhost:3355出现404,这是因为tomcat中的webapps目录中没有任何项目。 将webapps.dist中的项目复制到webapps中： 1root@8be6bf1b1aa5:/usr/local/tomcat# cp -r webapps.dist/* webapps 再次访问localhost:3355则出现tomcat欢迎界面。 Docker可视化界面portainer是Docker图形化界面管理工具。 12$ docker run -d -p 8088:9000 \\--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 访问测试：localhost:8088 Docker镜像讲解镜像是什么镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 如何得到镜像： 从远程仓库下载 从朋友处拷贝 自己制作一个镜像Dockerfile Commit命令将现有容器打包成镜像。 1234567$ docker run -it tomcat /bin/bashroot@cdcbb2f5b3aa:/usr/local/tomcat# lsBUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.distCONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps workroot@cdcbb2f5b3aa:/usr/local/tomcat# cd webappsroot@cdcbb2f5b3aa:/usr/local/tomcat/webapps# lsroot@cdcbb2f5b3aa:/usr/local/tomcat/webapps# docker提供的tomcat镜像中的webapps目录下没有项目。 将webapp.dist目录中的项目复制到webapps目录下： 1234root@cdcbb2f5b3aa:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@cdcbb2f5b3aa:/usr/local/tomcat# cd webappsroot@cdcbb2f5b3aa:/usr/local/tomcat/webapps# lsROOT docs examples host-manager manager 将该容器打包成镜像： 使用方式： docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 1$ docker commit -a=&quot;lize&quot; -m=&quot;add webapps apps&quot; 53b95fab247a tomcat01:1.0 -a表示作者，-m表示提交的描述信息 使用数据卷使用方式： $ docker run -it -v [主机目录]:[容器内目录] 容器 /bin/bash 示例： 1$ docker run -it -v /home/test:/home centos /bin/bash 实战： 将mysql配置目录和数据目录与主机目录进行双向绑定： 12$ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysqlda57dd0c24e10ccec927594c1c5adc83a5ae60207697cd8a2d73ed0a9b777059 -d 后台运行 -p 端口映射 -v 数据卷挂载 -e 环境配置 –name 容器名字 上面这条命令完成了以下操作： 在后台运行mysql 将主机3310端口映射到此容器的3306端口 将主机/home/mysql/conf目录与容器中的etc/mysql/conf.d目录双向绑定 将主机/home/mysql/data目录与容器中的/var/lib/mysql目录双向绑定 配置mysql的密码为123456 容器的名称为mysql01 在主机上使用mysql workbench连接localhost:3310，如果连接成功，这就表示端口映射成功。然后使用mysql workbench创建一个名称为test的数据库，在主机的/home/mysql/data目录查看，发现多出一个test目录，并且数据卷挂载成功！ 容器删除后，test目录将依旧存在。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"CodeLite调试时查看数组内容","slug":"CodeLite调试时查看数组内容","date":"2021-01-03T04:04:33.000Z","updated":"2021-01-03T04:06:18.056Z","comments":true,"path":"2021/01/03/CodeLite调试时查看数组内容/","link":"","permalink":"http://example.com/2021/01/03/CodeLite%E8%B0%83%E8%AF%95%E6%97%B6%E6%9F%A5%E7%9C%8B%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9/","excerpt":"","text":"添加监视的变量名为： 1(int[10]*)a","categories":[],"tags":[{"name":"CodeLite","slug":"CodeLite","permalink":"http://example.com/tags/CodeLite/"}]},{"title":"vscode配置c++环境","slug":"vscode配置c-环境","date":"2021-01-02T09:52:52.000Z","updated":"2021-01-02T10:09:52.737Z","comments":true,"path":"2021/01/02/vscode配置c-环境/","link":"","permalink":"http://example.com/2021/01/02/vscode%E9%85%8D%E7%BD%AEc-%E7%8E%AF%E5%A2%83/","excerpt":"","text":"vscode配置c++环境1.配置c++ IntelliSense使用F1 快捷键打开命令选项，输入C/C++:Edit configuration，然后在.vscode文件夹自动生成c_cpp_properties.json配置文件。 2.launch.json配置文件在debug界面中添加配置，然后选c++(gdb/lgdb)选项，然后自动生成launch.json配置文件，该配置文件主要用于调试时的加载控制。 3.tasks.json配置文件在命令窗口中输入task，选择task:configure task选项，生成task.json配置文件。 注意：task.json中的label属性值要和launch.json中preLaunchTask属性值相同。","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-01T07:22:59.521Z","updated":"2021-01-08T13:56:00.737Z","comments":true,"path":"2021/01/01/hello-world/","link":"","permalink":"http://example.com/2021/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 成功啦o(*￣▽￣*)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 折叠框的标题 被折叠的内容 1被折叠的内容 2… 面板框的标题 面板里的内容 1面板里的内容 2… TYPE是面板框的类型，可以是： successs danger info warning test","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://example.com/tags/ubuntu/"},{"name":"CodeLite","slug":"CodeLite","permalink":"http://example.com/tags/CodeLite/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"}]}