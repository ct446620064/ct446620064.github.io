[{"title":"PPA","date":"2021-01-06T16:00:00.000Z","url":"/2021/01/07/PPA/","tags":[["ubuntu","/tags/ubuntu/"]],"categories":[["undefined",""]],"content":"PPA(Persional Package Archive)参考资料： 私人包存档，这暗示对一个开发人员独有的东西，是非官方支持的发布。 Ubuntu提供了一个叫做Launchpad的平台使软件开发人员能够创建属于他们自己的仓库。你可以将PPA repository加入到你的sources.list里面当你更新你的系统时，你的系统将知道新软件的可用性，并且你可以使用标准的sudo apt install命令安装这个软件。 sudo add-apt-repository ppa:dr-akulavich/lighttable 这个命令中没有URL，是因为the tool被设计使用抽象信息表达URL。 如果你添加ppa:dr-akulavich/lighttable，那么你就会获得Light Table，但是如果你添加ppa:dr-akulavich，那么你就会获得一个更高级库里面所有的库和软件包，它是分层的。 基本上，当你使用add-apt-repository命令添加PPA时所做的操作就如同运行下面这些命令： deb  YOUR_UBUNTU_VERSION_HERE maindeb-src  YOUR_UBUNTU_VERSION_HERE main 上面这两行是添加任何仓库（repositories）到你的sources.list的传统方式。 但是PPA对你来说是自动的，无需担心精准的repository URL地址和操作系统版本。 一个要提及的重要的事就是当你使用PPA的时候，他不会改变你的原来的sources.list文件，而它会在/etc/apt/sources.d目录中创建两个文件，一个list文件和一个备份文件（后缀为save）。 以list为后缀的文件包含添加关于库的信息的命令。 这是一个确保添加PPA不会弄乱原来的sources.list文件的安全的措施，也可以帮助删除PPA。 为什么是PPA？为什么不是DEB包？你也许会问为什么你应该使用PPA，当涉及到使用不是每个人偏爱的命令行的时候。为什么不直接发布能详细安装的DEB包？ 答案在于更新过程。如果你使用DEB包安装软件，则不能保证安装的软件在你运行sudo apt update &amp;&amp; sudo apt upgrade命令时能被更新。 因为apt upgrade过程依赖sources.list，如果没有软件条目，那么他就无法通过标准软件更新获得更新。 所以，这就意味着使用DEB包安装的软件将永远不会获得更新？不是，这要看这个包是如何被创建的。 一些开发者自动添加一个条目到sources.list，然后这个软件就像常规软件那样更新。Google Chrome就是这样一个例子。 当你试图运行一些软件时，它会通知你新版本的可用性。你将不得不下载一个新的DEB包，然后再次运行以更新当前软件到一个新的版本。Oracle Virtual Box就是这样一个例子。 对于剩下的DEB包，你将不得不手动寻找一个更新，并且这样并不方便，特别是如果你的软件是为了"},{"title":"Docker常用命令","date":"2021-01-03T08:13:14.000Z","url":"/2021/01/03/Docker/","tags":[["Docker","/tags/Docker/"]],"categories":[["undefined",""]],"content":"Docker和虚拟机的不同： 传统虚拟机，虚拟出一套硬件，在硬件之上运行一个完整的操作系统，然后在操作系统上安装和运行软件。 容器内的应用直接运行在宿主机的内核上，容器没有自己的内核，也没有虚拟出硬件。 每个容器之间是相互隔离的，每个容器都有一个属于自己的文件系统，互不影响。 Docker镜像命令查看镜像使用方式： docker images [option] [repository[:TAG]] 示例： ​​ 字段名 含义 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像ID CREATED 镜像创建时间 SIZE 镜像的大小 Option选项 描述 –all , -a # 显示所有镜像 (default hides intermediate images) –digests # Show digests –filter , -f # Filter output based on conditions provided –format # Pretty-print images using a Go template –no-trunc #Don’t truncate output –quiet , -q # Only show image IDs 搜索镜像使用方式： docker search [OPTION] TERM 示例： 查看某个命令的可选项使用方式： docker [命令名称] –help 示例： 下载镜像使用方式： docker pull [OPTION] NAME[:TAG|@DIGEST] 示例： 如果不写TAG，则默认下载最新的镜像。 以下两个命令等价： 指定版本下载： 删除镜像使用方式： docker rmi [OPTIONS] IMAGE [IMAGE…] 示例： 删除所有的镜像： 其中$(docker images -aq)为查询所有镜像的ID Docker容器命令安装centos进行测试 新建容器并运行 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 示例： 查看容器 docker ps [OPTIONS] 示例： Option名称 描述 -all, -a 显示所有容器 –last, -n 显示最近创建的n个容器 –quiet, -q 只显示容器的ID 退出容器退出并关闭容器 exit 退出但不关闭容器 Ctrl + P + Q 删除容器使用方式： docker rm [OPTIONS] CONTAINER [CONTAINER…] Option选项 描述 --force , -f Force the removal of a running container (uses SIGKILL) --link , -l Remove the specified link --volumes , -v Remove anonymous volumes associated with the container 示例： 启动容器 重启容器 停止容器 强制停止当前容器 常用其他命令后台运行容器 docker run -d centos中的-d表示后台运行，但是该后台运行必须对应一个前台进程，否则docker会将这个容器停止。 查看日志 -tf表示显示日志， --tail [数字]表示要显示日志条数。 查看容器内部进程 示例： 查看容器的元数据 进入当前正在运行的容器 或者 两者区别：docker exec 在进入容器后开启一个新的终端，docker attach 在进入容器后使用正在执行的一个终端。 将容器内部的文件拷贝到主机上 ![](/home/lize/Pictures/Screenshot from 2021-01-05 23-14-52.png) 作业1：docker部署nginxdocker部署nginx并完成端口映射 作业2：docker部署tomcat官方使用： --rm表示停止容器后将无法查询到该容器，先在本地镜像中寻找tomcat，本地镜像没有则去docker 仓库下载。 后台运行tomcat： 但是访问localhost:3355出现404,这是因为tomcat中的webapps目录中没有任何项目。 将webapps.dist中的项目复制到webapps中： 再次访问localhost:3355则出现tomcat欢迎界面。 Docker可视化界面portainer是Docker图形化界面管理工具。 访问测试：localhost:8088 Docker镜像讲解镜像是什么镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 如何得到镜像： 从远程仓库下载 从朋友处拷贝 自己制作一个镜像Dockerfile Commit命令将现有容器打包成镜像。 docker提供的tomcat镜像中的webapps目录下没有项目。 将webapp.dist目录中的项目复制到webapps目录下： 将该容器打包成镜像： 使用方式： docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] -a表示作者，-m表示提交的描述信息 使用数据卷使用方式： $ docker run -it -v [主机目录]:[容器内目录] 容器 /bin/bash 示例： 实战： 将mysql配置目录和数据目录与主机目录进行双向绑定： "},{"title":"CodeLite调试时查看数组内容","date":"2021-01-03T04:04:33.000Z","url":"/2021/01/03/CodeLite%E8%B0%83%E8%AF%95%E6%97%B6%E6%9F%A5%E7%9C%8B%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9/","tags":[["CodeLite","/tags/CodeLite/"]],"categories":[["undefined",""]],"content":"添加监视的变量名为： "},{"title":"vscode配置c++环境","date":"2021-01-02T09:52:52.000Z","url":"/2021/01/02/vscode%E9%85%8D%E7%BD%AEc-%E7%8E%AF%E5%A2%83/","tags":[["vscode","/tags/vscode/"]],"categories":[["undefined",""]],"content":"vscode配置c++环境1.配置c++ IntelliSense使用F1 快捷键打开命令选项，输入C/C++:Edit configuration，然后在.vscode文件夹自动生成c_cpp_properties.json配置文件。 2.launch.json配置文件在debug界面中添加配置，然后选c++(gdb/lgdb)选项，然后自动生成launch.json配置文件，该配置文件主要用于调试时的加载控制。 3.tasks.json配置文件在命令窗口中输入task，选择task:configure task选项，生成task.json配置文件。 注意：task.json中的label属性值要和launch.json中preLaunchTask属性值相同。"},{"title":"Hello World","date":"2021-01-01T07:22:59.521Z","url":"/2021/01/01/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]